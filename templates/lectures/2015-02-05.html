{% extends "layout.html" %}

{% block content %}
<section>
    <h1>String Matching</h1>
</section>
<section>
    <p>Given a word $W$ determine if $W$ occurs in a main text string $S$</p>
</section>
<section>
    <p>What's the first, intuitive way that you would solve this problem?</p>
</section>
<section>
    <p>Perhaps something like this?</p>
<pre><code class="java">public boolean stringContains(String word, String mainText) {
    // Untested, beware...
    for(int i = 0; i &lt; mainText.length() - word.length(); i++) {
        boolean allCharactersMatch = true;
        for(int j = 0; j &lt; word.length(); j++) {
            if(mainText.charAt(i + j) != word.charAt(j)) {
                allCharactersMatch = false;
                break; // break out of inner loop. j = word.length(); works too.
            }
        }

        if(allCharactersMatch) {
            return true;
        }
    }

    return false;
}</code></pre>
</section>
<section>
    <p>
    What's this doing?
    </p>
</section>
<section>
    <section>
        <p>This tries to "align" $W$ (called word here) by scooting it along $S$ (called mainText here) and checking if all the
        characters match. For instance, let $W = cat$ and $S = cacat$. The first step of the outer loop would look something like
        <pre>cacat
cat</pre>
        <p>Which would not match</p>
    </section>
    <section>
        <p>The second loop would be</p>
        <pre>cacat
 cat</pre>
        <p>(No match)</p>
    </section>
    <section>
        <p>And the third</p>
        <pre>cacat
  cat</pre>
        <p>Which would match</p>
    </section>
</section>
<section>
    <section>
        <h3>This runs in $O(n^2)$ time</h3>
    </section>
    <section>
        <h4>Quick review of $O$ notation</h4>
    </section>
    <section>
        <ul>
            <li>
                $O(n^2)$ simply means that for a given algorithm given input of size $n$, it takes
                <i>on the order</i> of $n^2$ time to run the algorithm.
            </li>
            <li>
                So, if it runs in 2 seconds for $n=1$, for $n=3$ it'll run in roughly 6 seconds
                (the input increased by 2, so the time increased by $2^2$).
            </li>
            <li>
                You can spot this by seeing the doubly nested for loops.
            </li>
        </p>
    </section>
</section>
<section>
    <section>
        <h3>Is this acceptable?</h3>
    </section>
    <section>
        <p>For small cases, sure! If my strings are of length 20, I'll have to do 400 iterations. Not a big deal</p>
    </section>
    <section>
        <p>What if you're trying to match a sequence of DNA to another (which is pretty common)?</p>
        <p>
            Let's consider the HIV virus, which has 9,749 base pairs. Now, our loop has to perform 95043001 iterations.
            This <i>might</i> be okay, but we can see this breaking down.
        </p>
    </section>
</section>
<section>
    <section>
        <h3>Is there a faster way?</h3>
    </section>
    <section>
        <p>We can actually do this in linear time: $O(n)$.
    </section>
    <section>
        <p>Check out the [Knuth-Morris-Pratt Algorithm](http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm).</p>
        <p>
            Basic Idea: The naive solution jumps back to the beginning and starts over if there's a mismatch. KMP
            instead builds a table up-front (in linear-time) that tells your algorithm WHERE in the mainText to jump back to.
    </section>
    </section>
    http://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/java/lang/String.java#l1715
{% endblock %}
