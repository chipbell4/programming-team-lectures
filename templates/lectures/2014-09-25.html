{% extends "layout.html" %}

{% block content %}
<section>
<h2>Last Week's Problems</h2>
<p>Again, looking at two. Oddly enough, we've done these before</p>
<ul>
	<li><a href="/?lecture=2013-10-17#/lily">Lily's Birthday Party</a></li>
	<li><a href="/?lecture=2013-10-17#/sprial">Spiral</a></li>
</ul>
</section>
<section>
<h2>A Topic: Graphs</h2>
<p>
<img src="http://qph.is.quoracdn.net/main-qimg-06d9885ad7275a70a9ac161c2304086a?convert_to_webp=true" />
</p>
<p>
A graph is data structure consisting of nodes connected by edges. Can represent any sort of connected data
</p>
<ul>
	<li>Computer Networks</li>
	<li>Cities and Streets (edges are roads and nodes are street corners)</li>
	<li>Social Networks (nodes are people, and edges are follows)</li>
</ul>
</section>
<section>
<h2>Why Use Them</h2>
<p>
Over the years we developed optimized ways for dealing with problems on graphs, and so representing familiar problems
as a graph allows us access to all of that knowledge and set of algorithms.
</p>
</section>
<section>
	<section>
	<h2>Some Common Problems</h2>
	</section>
	<section>
		<p>
		Given "weighted" nodes, what is the least cost path from a given node to another (think Google Maps)?
		Use <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm">Dijkstra's Algorithm</a> or even
		<a href="http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman-Ford</a>. What about all
		shortest paths at once? <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall</a>
		will do it.
		</p>
	</section>
	<section>
		<p>
		Given a start node and end node, is there even a path to a given node (maze solving)?
		Try <a href="http://en.wikipedia.org/wiki/Depth-first_search">Depth-First Search</a>
		Or <a href="http://en.wikipedia.org/wiki/Breadth-first_search">Breadth-First Search</a>.
		It's worth knowing the differences too.
		</p>
	</section>
	<section>
		<p>
		How about a minimum spanning tree (minimum amount of cable to connect power stations). Try
		<a href="http://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal's</a> or
		<a href="http://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim's</a>	Algorithm
		</p>
	</section>
	<section>
		<p>
		Finding the maximum "flow" from one end of a network to the other? There's a lot here,
		but <a href="http://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm">Push-Relabel</a>
		is going to be the most efficient (don't quote me).
		</p>
	</section>
	<section>
		<p>
		And <a href="http://en.wikipedia.org/wiki/List_of_algorithms#Graph_algorithms">the list</a>
		goes on and on. Most importantly, learn how to model a problem as a graph problem.
		</p>
	</section>
</section>
<section>
	<section>
	<h2>How Do We Represent A Graph</h2>
	<ul>
		<li>A matrix of weights</li>
		<li>An adjacency list</li>
	</ul>
	</section>
	<section>
	<h2>Matrix Form</h2>
	<p>
		$
		\left(
		\begin{array}{ccc}
			0 & 1 & 1 \\
			1 & 0 & 1 \\
			1 & 0 & 0 \\
		\end{array}
		\right)
		$
	</p>
	<p>
	This would mean node 1 is connected to both three and two. Node two and three are both connected to node 1. Node two
	is also connected to node 3.
	</p>
	</section>
	<section>
		<h2>Why Use Matrix Representation</h2>
		<ul>
			<li>Some algorithms present themselves as a matrix math problem (Floyd-Warshall comes to mind)</li>
			<li>
				Given a node $m$ and $n$, it's easy to figure out if $m$ is connected $n$: Just check out your array:
				<code>matrix[m][n] ? "Yes" : "No";</code>
			</li>
		</ul>
	</section>
	<section>
		<h2>Why Not Use Matrix Representation</h2>
		<ul>
			<li>Sparse graphs will take up a lot of memory, only to store a bunch of zeros</li>
			<li>
				Its $O(n)$ time to count the number of edges coming out of a node $m$ because you have to
				loop over a row of the matrix counting the non-zeros.
			</li>
		</ul>
	</section>
	<section>
		<h2>Adjacency List</h2>
		<pre><code class="hljs python">
matrix[1] = [2, 3]
matrix[2] = [1, 3]
matrix[3] = [1]
		</code>
		</pre>
		<p>
		<code>matrix</code> can be a hash table, list, or whatever. In this case, the representation is different,
		but they store the same graph.
		</p>
	</section>
	<section>
		<h2>Why Use An Adjacency List?</h2>
		<ul>
				<li>Stores sparse graphs very effectively. You only store the edges you need, rather than allocating space for edges that don't exist</li>
				<li>
					Counting the number of edges from a single node is quick, because most list implementations cache it so it's generally $O(n)$ to count.
				</li>
		</ul>
	</section>
	<section>
		<h2>Why Not Use An Adjacency List?</h2>
		<ul>
			<li>
			Determining if a $m$ is connected to $n$ is worst case $O(n)$ time since you potentially have to loop over all edges from a given node.
			(Note: If you store the edges as a set, you can get $O(1)$ time depending on your set implementation)
			</li>
		</ul>
	</section>
	<section>
		<h2>Which should I use?</h2>
		<p>If you're hacking one up, the matrix will be easier (I think). However...</p>
		<p>Remember the first lecture? You should go into the competition with your implementation + these algorithms already implemented!</p>
	</section>
</section>
<section>
<h2>Your "Homework"</h2>
<ul>
	<li>Find (or write) a well-tested graph implementation in your language of choice (I prefer adjacency list method)</li>
	<li>Bonus points if you can attach meta-data to nodes or edges (names, locations, weights, whatever)</li>
	<li>SUPER Bonus points if you have implementations of some of these algorithms, with hook-ins for custom code</li>
	<li>Research some of these algorithms. Get your head wrapped around them (BFS and DFS at least. Senior folks: go for maximum-flow)</li>
</ul>
</section>
{% endblock %}
